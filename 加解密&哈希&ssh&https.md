# 加解密  哈希   SSH    HTTPS
## Encryption 和 Hash（哈希）的区别
1. 从信息论角度

    -  Encryption 是可逆的，没有信息熵的改变。
    -  Hash是不可逆，把东西打散，一般会导致信息熵减少


2. 应用角度

   - Encryption 常用来做为密钥的加解密（AES, RSA, ECC）
   - Hash 常被用于做数字签名， 数据校验（CRC, SHA, MD5）


3. 形象比喻
   - Encryption 就是带密码的保险箱
   - Hash就榨汁机，有去无回

## 加密算法分为对此(Symmetric)  非对称(Asymmetry)两大类
  + 对称加密核心在于加密、解密的密钥是一样的

     - 凯撒密码
     - AES(Advanced Encryption Standard)
     - SM1 SM4
     - DES、3DES、 RC4等

  + 非对称(Asymmetry)加密
  加密，解密的密钥分为两组，而且不能相互反推。这种算法在现实生活中很难类比。大致就是通过某算法生成一对密钥对k1， k2 ，用k1加密之后的密文只能用k2解密，用k2加密的密文只能用k1解密
   - 基于因数分解的算法

     RSA、DSA是其中的代表，Linux的SSH就是基于这两种算法进行文件 key auth。由于GPU和超级计算机的算力提升，好多Linux发行版默认是2048位

  - 椭圆曲线算法（Elliptic Curve Cryptography  ECC）
     可以用1/6的密钥长度达到RSA更高的强度。不太懂数学

  非对称加密算法非常安全，但是慢。RSA的加密速度是AES的1/30。 就出现了SSL TLS。

  ## HTTP + TLS = HTTPS
  TLS 的前身是SSL
   - SSL(Secure Socket Layer, 安全套接字层)，为Netscape研发。SSL协议位于TCP/IP协议与各应用层协议之间。
   - TLS跟SSL 是有差异的。我还是不太理解具体差异。

   做个比喻 A与B通信， A是SSL客户端，B是SSL服务端，加密的消息放在[] 里，以突出明文消息的区别，双方的处理的动作放在()里说明  

   A： 我想和你安全通话，我这里的对称算法有DES RC5 密钥交换算法有RSA和DH，摘要算法有MD5 和SHA

   B： 我们用DES－RSA－SHA 这对组合好了。
   这是我的证书，里面有我的姓名和公钥，你拿去验证一下我的身份（把证书发给A）

   A：(查看证书上B的姓名是否无效，并通过手头上已有的CA证书验证了B证书的真实性，如果其中一项有误，就发出警告断开连接，这一步保证了B公钥的真实性)
   （产生一份秘密消息，这份秘密消息将用做加密密钥，加密初始化向量（IV）和 hmac的密钥。将这份秘密消息－协议称为  per_master_secert 用B的公钥加密，封装成ClientKeyExchange的消息，由于用B的公钥，保证第三方无法窃听）
   我生成一份秘密消息，并用了你的公钥进行加密，给你（ ClientKeyExchange发给B）
   注意 下面我将用加密的办法给你发信息！
   （将秘密进行处理，生成加密密钥， 加密初始化向量和hmac的密钥）
   ［我说完了］

   B:(用自己的私钥将ClientKeyExchange中的秘密消息解密出来，然后将秘密消息进行处理，生成加密密钥，初始化加密向量和hmac的密钥，这时双方已经安全协商出一套加密办法了)
   注意，我也要开始用加密的办法给你发消息了！                                  
   ［我说完了］

   A:[我的秘密是。。。。。。。]

   B:[其他人是听不到的]

   上个图

   ![TLS流程图](http://o7q7atccj.bkt.clouddn.com/tls-ssl.svg)
   TODO： 理解HTTPS更多背后的原理。知识的广度是知识的深度的副产品



## ssh

SSH 是Secure Shell 的缩写，是建立在应用层的和传输层基础上的安全协议。维计算机运行的Shell提供安全的传输和使用环境。

   传统的rsh、FTP、POP、Telnet协议在传输过程中采用明文，很容易受到中间人攻击。最初SSH协议是由芬兰的一家公司于1995年设计开发的，受版权和加密算法的限制，很多人转向OpenSSH。

从客户端来讲，SSH提供了两种安全验证方式
1. 基于口令。客户端使用账户和密码登陆服务器，所有传输数据都会被加密，但是可能存在冒充服务器于客户端进行交互（蜜罐），不能避免中间人攻击。

2. 基于密钥。使用一对密钥（私钥 公钥）将公钥放在服务器上注册（$HOME/.ssh/authorized_keys 文件中）。当客户端登陆服务器，服务器会使用公钥进行安全验证，服务器首先对比从客户端发过来的公钥，与注册的公钥是否一致，如果一致，服务器会用公钥加密数据向客户端发起 “挑战”（客户端用私钥进行解密，把答案发给服务器进行验证，如果挑战成功，可以开始安全通讯），

第一次连接服务器时，客户端没有目标服务器的公钥存根，会提示服务器公钥的指纹（公钥字符进行MD5或者SHA－1得到), 如果你已经知道服务器公钥，可以根据提示，算出指纹，进行比对。一旦确认指纹正确并建立连接，客户端会保存服务器公钥在  $HOME/.ssh/known_host 文件中。当再次链接服务器时，会进行检查，如果提示公钥存根不一样，**要提高警惕了**。
虽然有几种原因。目标服务器更换公钥；目标服务器更换了IP地址或者域名；恶意攻击者截断了连接，使用伪造的主机地址欺骗你建立连接。

其实SSH除了登陆服务器，传输文件，**还可以端口转发**。
- 绑定端口
> ssh -D 8080 user@host

SSH会建立一个socket，监听本地的8080端口，一旦有数据传向这个端口，将自动把它转到SSH连接上，发往远程主机。从不加密端口转向加密端口(简单粗暴的fq)。


- 端口转发
>ssh -L 2121:host2:21    host3

指定SSH绑定本地端口2121，然后指定host3将所有数据转发到host2的21 端口上。只要连接上本地的2121 端口，相当连上host2的21端口。 这时什么场景下使用？
host1 是本地主机， host2是远程主机，但 host1 连通不了 host2，但host3 可以同时连通 host1和host2。

如果这样？
>ssh -L 5900:localhost:5900 host3

将本地的5900绑定到host3上的5900端口

>ssh -L 9001:host2:22 host3

只要登陆本机的9001端口，就相当与登陆host2


-  远程端口的转发

 在host3主机上执行
 >ssh -R 2121:host2:21 host1

 让host1监听自己的2121端口，然后将所有的数据经由host3，转发到host2的21端口

为了更好的性能表现 ，加 C 参数压缩数据。 加f参数，SSH连接成功后，转入后台，要关闭这个后台连接，只能kill对应进程。N参数，只连接远程主机，不打开远程shell。T参数，不为这个连接分配TTY，NT可以一起用。
