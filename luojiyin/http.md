1. 二进制协议， 不再是纯文本
2. 可发起多个请求，废弃了1.1 的管道
3. 使用专用算法压缩头部，减少数据传输量
4. 允许服务器主动向客户端推送数据
5. 增强了安全性， “事实上”要求加密传输

代理很多类型，常见的
1. 匿名代理： 完全“隐匿”了代理服务器，外界只看到的是代理服务器
2. 透明代理： 在传输过程中是“透明开放”的， 外界知道代理， 也知道客户端
3. 正向代理： 靠近客户端，代表客户端向服务器发送请求
4. 反向代理： 靠近服务器端，代表服务器响应客户端的请求
-----------------------------------
1. 负载均衡
2. 内容缓存
3. 安全防护： 隐匿ip，使用WAF等工具抵御网络攻击， 保护被代理的机器
4. 数据处理： 提供压缩 加密等额外的功能




TCP/IP四层
1. 链接层（link layer）负责在以太网 WiFi这样的底层网络发送原始数据包，
工作在网卡这个层次， 使用MAC地址来标记网络上的设备，所以有时也叫MAC层

2.  网际层或者叫 网络互连层(interner layer)，IP协议就处在这一层。因为IP协议定义了
“IP地址”的概念，所以就可以在“链接层”的基础上，使用IP代替MAC 地址，把很多的局域网，
广域网连接成一个虚拟的巨大网络，在这个网络找设备只要把IP 翻译成MAC 地址就可以了。

3. 传输层(transport layer) 这个层次协议是保证数据在IP地址标记的两点的可靠传输， 是TCP协议工作
的层次，另外还有它的一个小伙伴 UDP

TCP 是一个状态的协议，需要先与对方建立连接后才能发送数据，而且保证数据不丢失不重复，UDP比较简单，无状态
不需要先建立连接就可以随意发送数据，但不保证数据一定发到对方。两个协议另一个重要的区别在于数据的形式
TCP的数据是持续的“字节流”有先后顺序
UDP是分散的数据小包，是顺序发，乱序收


4. 应用层(application layer)   有面向具体应用的协议 如Telnet SSH FTP  SMTP HTTP

MAC层的传输单位是帧(frame) IP层是包(packet)  TCP是段(segment),  HTTP 是消息火灾报文(message)
但这些名词没什么本质的区别， 可以统称为数据包

-------------------------------
OSI 7层
第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；
第二层：数据链路层，它基本相当于 TCP/IP 的链接层；
第三层：网络层，相当于 TCP/IP 里的网际层；
第四层：传输层，相当于 TCP/IP 里的传输层；
第五层：会话层，维护网络中的连接状态，即保持会话和同步；
第六层：表示层，把数据转换为合适、可理解的语法和语义；
第七层：应用层，面向具体的应用传输数据。

第一层：物理层，TCP/IP 里无对应；
第二层：数据链路层，对应 TCP/IP 的链接层；
第三层：网络层，对应 TCP/IP 的网际层；
第四层：传输层，对应 TCP/IP 的传输层；
第五、六、七层：统一对应到 TCP/IP 的应用层。

OSI 的分层模型在四层以上分的太细，而 TCP/IP 实际应用时的会话管理、编码转换、压缩等和具体应用经常联系的很紧密，很难分开。

二层转发 二层是指数据链路层，工作在二层的设备，通过查找目标的MAC地址， 进行数据转发

三层路由 三层是指网络层， 设备工作在三层，通过解析数据包头消息，找出目标IP 地址， 转发数据


-----------------------------------------
HTTP报文结构
1. 报文结构就像大头儿子，起始行 + 头部 + 空行 + 实体 组成，简单来说就是 header + body 

2. HTTP报文可以没有body，但必须有header，而且header后也必须有空行， 

3. 请求头由 请求行 + 头部字段构成 ，响应头由状态行 + 头部字段 构成

4. 请求行有三部分    请求方法   请求目标 和版本号

5. 状态行也有三部分  版本号   状态码 和   原因字符串

6. 头部字段是key-value的形式， 用“:” 分隔，不区分大小写， 顺序任意，除了规定的标准头，
也任意添加自定义的字段， 实现功能扩展

7. HTTP/1.1  唯一要求的必须提供的头字段是Host, 它必须出现在请求头里， 标记虚拟主机名

HTTP/1.1  8种方法
1. GET： 获取资源，可以理解为读取或者下载数据
2. HEAD: 获得资源的元消息
3. POST： 向资源提交数据， 相当写入或上传数据
4. PUT： 类似POST
5. CONNECT:  建立特殊的连接隧道
6. DELETE:   删除资源
7. OPTIONS： 列出可对资源实行的方法
8. TRACE： 跟踪请求-响应的传输路径

-------------------------------
URI编码
某些特殊的 URI，会在 path、query 里出现“@&?"等起界定符作用的字符，会导致 URI 解析错误

URI引入了编码机制  对于ASCII码以外的字符集和特殊字符做了一个特殊操作
把它们转换成与URI语义不冲突的形式，在RFC 规范称为 'escape' 和'unescape' 俗称的“转义”

URI 转义的规则有点“简单粗暴”，直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”。

有了这个编码规则后，URI 就更加完美了，可以支持任意的字符集用任何语言来标记资源。

-------------------------------
状态码
1xx : 提示信息，表示目前是协议处理的中间状态，还要后续的处理
2xx ：成功， 报文收到并被正确处理
3xx : 重定向 资源位置发生变动  需要客户端重新发送请求
4xx ：客户端错误   请求报文有误    服务器无法处理
5xx ：服务器端错误    服务器在请求处理请求时发生了错误


-------------------------------
HTTP传输大文件
1. 压缩HTML等文本文件是传输大文件最基本的方法
2. 分块传输可以流式发送数据，节约内存和宽带，使用响应头字段
"Transfer-Encoding:chunked"来表示，分快的格式是16进制长度头 + 数据块
3. 请求范围内可以只获取部分数据，即"分块请求"，实现视频拖动或者断点续传
使用请求头字段"Range"和响应字段"Content-Range",响应状态码必须是206 

4. 也可以一次请求多个范围，这时候响应报文的数据类型是"multipart/byteranges"
body里的多个部分会用boundary 字符串分隔


-------------------------------
1. 花钱购买硬件 软件或者服务可以直接提升网站的服务能力， 其中最有价值的是CDN
2. 不花钱优化HTTP的三个关键词 开源 节流 缓存
3. 后端应选用高性能的web服务器， 开启长连接， 提升TCP的传输效率
4. 前端应该启用gzip br压缩，减少文本，图片的体积，尽量少传不必要的头字段
5. 缓存是无论何时不能忘记的性能优化利器， 应该用Etag和 Last-modified字段标记资源
6. 升级到HTTP/2 能获得许多方面的性能提升， 但要留意一些HTTP/1 的“反模式”

-------------------------------
通常认为如果通信过程具备四个特性 可以认为是安全的    机密性  完整性 身份认证 和不可否认 

基本的形式是 "密钥交换算法 签名算法 对称加密算法  摘要算法" 
握手时使用ECDHE 算法进行密钥交换 （机密性）
用RSA签名和身份认证  （身份认证和不可否认）
握手后通行后使用AES对称算法 密钥256位 分组模式是GCM，（保证机密性）
 摘要算法SHA384 用于消息认证和产生随机数 （完整性）

HTTPS的语法 语义依然是HTTP 但把下层的协议由 TCP/IP 换成了SSL/TLS

只用对称加密算法 是绝对无法解决密钥交换的问题

公钥和私钥有个特别的"单向"性， 虽然都可以用来加密 解密， 但公钥加盟后 只能私钥
解密， 反过来私钥加密后只能用公钥解密

非对称加密可以解决 密钥交换 的问题。 网站秘密保存私钥， 在网上任意分发公钥   你想登陆网站
只要公钥加密就行了， 密文只能由私钥持有者才能解密。 黑客没有私钥， 就无法破解密文

然后用随机数产生对称算法使用的"会话密钥"  然后用公钥加密， 因为会话密钥很短， 通常只有16字节 或32字节
所以慢一点 也无所谓

对方用私钥进行解密， 取出会话密钥， 实现了对称密钥的交换， 后续就不再使用非对称加密，全程使用对称加密

-------------------------------
对称加密 和非对称加密，两者结合起来的混合实现了机密性
但黑客虽然拿不到会话密钥， 但通过窃听收集到足够多的密文
再尝试修改 重组后发给网站，但没有完整性，服务器只能"照单全收"
再通过服务器的响应获取进一步线索    最终会破解明文

通过 数字摘要 保证完整性。 不过摘要算法不具有机密性， 如果明文传输
黑客可以修改消息后 也把摘要也一起改了  还是鉴别不出完整性

完整性要建立在机密性上  哈希消息认证码(HMAC)

这里还是有漏洞的  就是通信的两个端点
黑客可以伪装成网站来窃取信息，反过来他也可以伪装成你
向网站发送支付 转帐等消息， 网站没有办法确认你身份，钱就可以这么偷走

使用私钥再加上摘要算法， 就能实现 数字签名 ，实现 身份认证 和 公钥解密

-------------------------------
解决   公钥信任
CA

CA 有时也会不可信，解决办法有 CRL、OCSP，还有终止信任


-------------------------------
HTTP/2还在一定程度上改变了传统的 "请求-应答" 工作模式
服务器不再被动地响应请求 也可以新建“流”主动向客户端发送消息

-------------------------------
google 提出了TCP fast open(TFO) 客户端可以首个SYN报文中携带请求 节省1个RTT时间
必须解决服务器信任的问题   服务器必须信任这个客户端

分为两个阶段
1 为首次建立链接 这时作正常的三次握手 但在客户端的SYN报文明确告诉服务器它想使用TFO功能
这样服务器会把客户端IP地址用只有自己知道的密钥加密(比如AES加密) 作为cookie携带在返回
SYN+ACK 报文中， 客户端接收到将cookie缓存在本地

2  如果客户端再次向服务器建立连接， 可以在第一个SYN报文中携带请求数据， 同时附带缓存的cookie
这中通信方法 不能 先connect再write这种编程方法， 而改用sendto 或者 sendmsg函数才能实现
服务器受到后， 会用自己的密钥验证 Cookie是否合法，验证通过连接才算建立成功，再把请求交给进程处理
同时返回SYN + ACK。 虽然客户端接收到还是返回ACK ，但服务器不等接收到ACK 就发送HTTP响应， 减少握手
带来的1个 RTT时间消耗

当然为了防止SYN洪水攻击    服务器的TFO 必须自动化定时更新密钥
Linux 如何打开 TFO 功能？ 
-------------------------------
四次挥手的优化
TCP不允许连接处于半打开状态时就单向传输数据，所以在三次握手建立连接时
服务器会把ACK和SYN一起发给客户端，其中， ACK用来打开客户端的发送通道
SYN用来打开服务器的发送通道。 这样四次握手 就降为三次握手了

但是当连接处在半连接状态时，TCP是允许单向数据传输数据的， 为了便于下午描述
把先关闭连接的一方叫做主动方 后关闭连接的一方叫做被动方 

当主动方关闭连接时，被动方还是可以在不调用close函数的状态下，长时间发送数据，此时连接处在半关闭状态。
这一特性是TCP的双向通道互相独立导致，却也使得关闭连接必须通过四次挥手才能做到

互联网中往往服务器才是主动关闭连接的一方。 


其实四次挥手只涉及了两种报文： FIN和ACK
谁发出FIN报文，表示它将不再发送任何数据， 
关闭这一方向的传输通道。
ACK 是确认的意思。 它用来通知对方：你方的发送通道已经关闭



