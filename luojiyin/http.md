1. 二进制协议， 不再是纯文本
2. 可发起多个请求，废弃了1.1 的管道
3. 使用专用算法压缩头部，减少数据传输量
4. 允许服务器主动向客户端推送数据
5. 增强了安全性， “事实上”要求加密传输

代理很多类型，常见的
1. 匿名代理： 完全“隐匿”了代理服务器，外界只看到的是代理服务器
2. 透明代理： 在传输过程中是“透明开放”的， 外界知道代理， 也知道客户端
3. 正向代理： 靠近客户端，代表客户端向服务器发送请求
4. 反向代理： 靠近服务器端，代表服务器响应客户端的请求
-----------------------------------
1. 负载均衡
2. 内容缓存
3. 安全防护： 隐匿ip，使用WAF等工具抵御网络攻击， 保护被代理的机器
4. 数据处理： 提供压缩 加密等额外的功能




TCP/IP四层
1. 链接层（link layer）负责在以太网 WiFi这样的底层网络发送原始数据包，
工作在网卡这个层次， 使用MAC地址来标记网络上的设备，所以有时也叫MAC层

2.  网际层或者叫 网络互连层(interner layer)，IP协议就处在这一层。因为IP协议定义了
“IP地址”的概念，所以就可以在“链接层”的基础上，使用IP代替MAC 地址，把很多的局域网，
广域网连接成一个虚拟的巨大网络，在这个网络找设备只要把IP 翻译成MAC 地址就可以了。

3. 传输层(transport layer) 这个层次协议是保证数据在IP地址标记的两点的可靠传输， 是TCP协议工作
的层次，另外还有它的一个小伙伴 UDP

TCP 是一个状态的协议，需要先与对方建立连接后才能发送数据，而且保证数据不丢失不重复，UDP比较简单，无状态
不需要先建立连接就可以随意发送数据，但不保证数据一定发到对方。两个协议另一个重要的区别在于数据的形式
TCP的数据是持续的“字节流”有先后顺序
UDP是分散的数据小包，是顺序发，乱序收


4. 应用层(application layer)   有面向具体应用的协议 如Telnet SSH FTP  SMTP HTTP

MAC层的传输单位是帧(frame) IP层是包(packet)  TCP是段(segment),  HTTP 是消息火灾报文(message)
但这些名词没什么本质的区别， 可以统称为数据包

-------------------------------
OSI 7层
第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；
第二层：数据链路层，它基本相当于 TCP/IP 的链接层；
第三层：网络层，相当于 TCP/IP 里的网际层；
第四层：传输层，相当于 TCP/IP 里的传输层；
第五层：会话层，维护网络中的连接状态，即保持会话和同步；
第六层：表示层，把数据转换为合适、可理解的语法和语义；
第七层：应用层，面向具体的应用传输数据。

第一层：物理层，TCP/IP 里无对应；
第二层：数据链路层，对应 TCP/IP 的链接层；
第三层：网络层，对应 TCP/IP 的网际层；
第四层：传输层，对应 TCP/IP 的传输层；
第五、六、七层：统一对应到 TCP/IP 的应用层。

OSI 的分层模型在四层以上分的太细，而 TCP/IP 实际应用时的会话管理、编码转换、压缩等和具体应用经常联系的很紧密，很难分开。

二层转发 二层是指数据链路层，工作在二层的设备，通过查找目标的MAC地址， 进行数据转发

三层路由 三层是指网络层， 设备工作在三层，通过解析数据包头消息，找出目标IP 地址， 转发数据


-----------------------------------------
HTTP报文结构
1. 报文结构就像大头儿子，起始行 + 头部 + 空行 + 实体 组成，简单来说就是 header + body 

2. HTTP报文可以没有body，但必须有header，而且header后也必须有空行， 

3. 请求头由 请求行 + 头部字段构成 ，响应头由状态行 + 头部字段 构成

4. 请求行有三部分    请求方法   请求目标 和版本号

5. 状态行也有三部分  版本号   状态码 和   原因字符串

6. 头部字段是key-value的形式， 用“:” 分隔，不区分大小写， 顺序任意，除了规定的标准头，
也任意添加自定义的字段， 实现功能扩展

7. HTTP/1.1  唯一要求的必须提供的头字段是Host, 它必须出现在请求头里， 标记虚拟主机名

HTTP/1.1  8种方法
1. GET： 获取资源，可以理解为读取或者下载数据
2. HEAD: 获得资源的元消息
3. POST： 向资源提交数据， 相当写入或上传数据
4. PUT： 类似POST
5. CONNECT:  建立特殊的连接隧道
6. DELETE:   删除资源
7. OPTIONS： 列出可对资源实行的方法
8. TRACE： 跟踪请求-响应的传输路径

-------------------------------
URI编码
某些特殊的 URI，会在 path、query 里出现“@&?"等起界定符作用的字符，会导致 URI 解析错误

URI引入了编码机制  对于ASCII码以外的字符集和特殊字符做了一个特殊操作
把它们转换成与URI语义不冲突的形式，在RFC 规范称为 'escape' 和'unescape' 俗称的“转义”

URI 转义的规则有点“简单粗暴”，直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”。

有了这个编码规则后，URI 就更加完美了，可以支持任意的字符集用任何语言来标记资源。

-------------------------------
状态码
1xx : 提示信息，表示目前是协议处理的中间状态，还要后续的处理
2xx ：成功， 报文收到并被正确处理
3xx : 重定向 资源位置发生变动  需要客户端重新发送请求
4xx ：客户端错误   请求报文有误    服务器无法处理
5xx ：服务器端错误    服务器在请求处理请求时发生了错误


-------------------------------
HTTP传输大文件
1. 压缩HTML等文本文件是传输大文件最基本的方法
2. 分块传输可以流式发送数据，节约内存和宽带，使用响应头字段
"Transfer-Encoding:chunked"来表示，分快的格式是16进制长度头 + 数据块
3. 请求范围内可以只获取部分数据，即"分块请求"，实现视频拖动或者断点续传
使用请求头字段"Range"和响应字段"Content-Range",响应状态码必须是206 

4. 也可以一次请求多个范围，这时候响应报文的数据类型是"multipart/byteranges"
body里的多个部分会用boundary 字符串分隔


-------------------------------
1. 花钱购买硬件 软件或者服务可以直接提升网站的服务能力， 其中最有价值的是CDN
2. 不花钱优化HTTP的三个关键词 开源 节流 缓存
3. 后端应选用高性能的web服务器， 开启长连接， 提升TCP的传输效率
4. 前端应该启用gzip br压缩，减少文本，图片的体积，尽量少传不必要的头字段
5. 缓存是无论何时不能忘记的性能优化利器， 应该用Etag和 Last-modified字段标记资源
6. 升级到HTTP/2 能获得许多方面的性能提升， 但要留意一些HTTP/1 的“反模式”

-------------------------------
通常认为如果通信过程具备四个特性 可以认为是安全的    机密性  完整性 身份认证 和不可否认 

基本的形式是 "密钥交换算法 签名算法 对称加密算法  摘要算法" 
握手时使用ECDHE 算法进行密钥交换 （机密性）
用RSA签名和身份认证  （身份认证和不可否认）
握手后通行后使用AES对称算法 密钥256位 分组模式是GCM，（保证机密性）
 摘要算法SHA384 用于消息认证和产生随机数 （完整性）

HTTPS的语法 语义依然是HTTP 但把下层的协议由 TCP/IP 换成了SSL/TLS

