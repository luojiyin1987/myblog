1.  Memcached 支持value类型为String类型
Redis 支持的value类型包括String 哈希表 列表 集合 
Redis 能够在实际业务场景中得到广泛的应用，得益于支持多样化类型的value

2. 索引的类型有很多， 常见的有哈希表 B+树   字典树，不同的索引结构在性能 空间消耗
并发控制有不同的特征， Memcached和Redis采用哈希表作为key-value 索引
而 RocksDB采用跳表作为内存中的 key-value的索引

3. 内存键值数据库中使用哈希表作为索引， 很大一部分原因在于，内存的高性能访问特性很好地与
哈希表O(1)的操作复杂度相匹配

4. Redis主要通过网络框架访问，而不再是动态库， 这也是Redis可以作为基础性的网络服务进行访问

5. Redis数据模型的value 类型很丰富, 因此也带来了更多的操作接口，例如面向列表的LPUSH/LPOP
面向集合的SADD/SREM 等， 

6. Redis持久化支持两种方式   日志(AOF)和快照(RDB) 

7. Redis 6种数据结构  string -->简单动态字符串   List -->双向链表(或 压缩列表)
Hash --> 哈希表(压缩列表)   Sorted Set -->压缩列表(或 跳表)   Set -->整数数组(哈希表  )

8. 为什么哈希表操作会变慢， 当往Redis中写入了大量的数据后，可能出现哈希表冲突问题和rehash操作带来的操作阻塞
Redis 解决哈希冲突的方式，就是链式哈希， 指同一个哈希通中的多个元素用一个链表保存，它们之间依次用指针连接
这里存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作
导致元素查找耗时长， Redis会对哈希表作rehash操作， 增加现有的哈希桶数量， 让entry元素分散在更多的桶中，减少桶中元素个数
其实为了更高效的操作， Redis默认使用了两个全局哈希表，哈希表1  哈希表2 
开始的时候  当插入数据时候 默认使用哈希表1  哈希表2 并没有被分配空间
当数据增多时， Redis开始执行rehash, 这个过错分为三步 
1 给哈希表2 分配更大的空间  ，例如是当前哈希表1 两倍
2 把哈希表1中的数据重新映射并拷贝到哈希表2 中
3 释放哈希表1的空间

如果一次性把哈希表1 中的数据都迁移完， 会造成Redis线程阻塞， 无法提供服务，
为避免这个问题， Redis采用渐进性 rehash
简单来说在第二步拷贝数据时， 每请求一个请求时， 从哈希表1 中的第一个索引位置开始，顺便把这个位置上的所有entries
拷贝到哈希表2 中， 等待下一个请求时， 再顺便拷贝哈希表1中下一个索引位置的entries 

