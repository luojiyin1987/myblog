1.  Memcached 支持value类型为String类型
Redis 支持的value类型包括String 哈希表 列表 集合 
Redis 能够在实际业务场景中得到广泛的应用，得益于支持多样化类型的value

2. 索引的类型有很多， 常见的有哈希表 B+树   字典树，不同的索引结构在性能 空间消耗
并发控制有不同的特征， Memcached和Redis采用哈希表作为key-value 索引
而 RocksDB采用跳表作为内存中的 key-value的索引

3. 内存键值数据库中使用哈希表作为索引， 很大一部分原因在于，内存的高性能访问特性很好地与
哈希表O(1)的操作复杂度相匹配

4. Redis主要通过网络框架访问，而不再是动态库， 这也是Redis可以作为基础性的网络服务进行访问

5. Redis数据模型的value 类型很丰富, 因此也带来了更多的操作接口，例如面向列表的LPUSH/LPOP
面向集合的SADD/SREM 等， 

6. Redis持久化支持两种方式   日志(AOF)和快照(RDB) 

7. Redis 6种数据结构  string -->简单动态字符串   List -->双向链表(或 压缩列表)
Hash --> 哈希表(压缩列表)   Sorted Set -->压缩列表(或 跳表)   Set -->整数数组(哈希表  )

8. 为什么哈希表操作会变慢， 当往Redis中写入了大量的数据后，可能出现哈希表冲突问题和rehash操作带来的操作阻塞
Redis 解决哈希冲突的方式，就是链式哈希， 指同一个哈希通中的多个元素用一个链表保存，它们之间依次用指针连接
这里存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作
导致元素查找耗时长， Redis会对哈希表作rehash操作， 增加现有的哈希桶数量， 让entry元素分散在更多的桶中，减少桶中元素个数
其实为了更高效的操作， Redis默认使用了两个全局哈希表，哈希表1  哈希表2 
开始的时候  当插入数据时候 默认使用哈希表1  哈希表2 并没有被分配空间
当数据增多时， Redis开始执行rehash, 这个过错分为三步 
1 给哈希表2 分配更大的空间  ，例如是当前哈希表1 两倍
2 把哈希表1中的数据重新映射并拷贝到哈希表2 中
3 释放哈希表1的空间

如果一次性把哈希表1 中的数据都迁移完， 会造成Redis线程阻塞， 无法提供服务，
为避免这个问题， Redis采用渐进性 rehash
简单来说在第二步拷贝数据时， 每请求一个请求时， 从哈希表1 中的第一个索引位置开始，顺便把这个位置上的所有entries
拷贝到哈希表2 中， 等待下一个请求时， 再顺便拷贝哈希表1中下一个索引位置的entries 

9. Sorted Set也采用了O(logN)复杂度的跳表， 不过集合类型的范围操作，因为要遍历底层数据， 复杂度通常时O(N) 可以用
其他命令代替， 比如用SCAN

10. List  有两种底层实现结构:  双向链表和压缩列表复杂度都是O（N） 它们的POP/PUSH效率很高 主要用于FIFO队列场景
而不是可以随机读写的集合。

11. Redis单线程是指 Redis的网络IO 和键值对读写是由一个线程完成的，这也是Redis对外提供键值对存储服务的主要流程
但Redis的其他功能 比如持久化 异步删除  集群数据同步等  其实由额外的线程执行的

12. 并发访问控制一直是多线程开发的一个难点。 、

13. 一方面Redis大部分操作是在内存上完成， 再加上它采用了高效的数据结构， 
另一方面， 就是Redis采用了多路复用机制，使再网络IO操作中能并发大量的客户请求

14. 小心AOF文件过大带来的性能问题  -->AOF重写机制
重写实现 多变一，把旧文件中的多个命令， 重写后变成一条命令
AOF日志由主线程写回不同， 重写过程是由后台线程 bgrewriteaof 来完成，
避免阻塞主线程， 导致数据库性能下降  
一个拷贝  两处日志
一个拷贝”就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。
此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。
然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。
“两处日志”又是什么呢？因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。

